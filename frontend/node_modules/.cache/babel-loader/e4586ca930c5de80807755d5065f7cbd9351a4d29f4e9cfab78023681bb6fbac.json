{"ast":null,"code":"/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport { difference } from \"lodash\";\nimport { isInterrupted, isModelTurn, isServerContenteMessage, isSetupCompleteMessage, isToolCallCancellationMessage, isToolCallMessage, isTurnComplete } from \"../multimodal-live-types\";\nimport { blobToJSON, base64ToArrayBuffer } from \"./utils\";\n\n/**\n * the events that this client will emit\n */\n\n/**\n * A event-emitting class that manages the connection to the websocket and emits\n * events to the rest of the application.\n * If you dont want to use react you can still use this.\n */\nexport class MultimodalLiveClient extends EventEmitter {\n  constructor({\n    url,\n    userId,\n    runId\n  }) {\n    super();\n    this.ws = null;\n    this.config = null;\n    this.url = \"\";\n    this.runId = void 0;\n    this.userId = void 0;\n    url = url || `ws://localhost:8000/ws`;\n    this.url = new URL(\"ws\", url).href;\n    this.userId = userId;\n    this.runId = runId || crypto.randomUUID(); // Ensure runId is always a string by providing default\n    this.send = this.send.bind(this);\n  }\n  log(type, message) {\n    const log = {\n      date: new Date(),\n      type,\n      message\n    };\n    this.emit(\"log\", log);\n  }\n  connect(newRunId) {\n    const ws = new WebSocket(this.url);\n\n    // Update runId if provided\n    if (newRunId) {\n      this.runId = newRunId;\n    }\n    ws.addEventListener(\"message\", async evt => {\n      if (evt.data instanceof Blob) {\n        this.receive(evt.data);\n      } else if (typeof evt.data === \"string\") {\n        try {\n          const jsonData = JSON.parse(evt.data);\n          if (jsonData.status) {\n            this.log(\"server.status\", jsonData.status);\n            console.log(\"Status:\", jsonData.status); // This will show in console\n          }\n        } catch (error) {\n          console.error(\"Error parsing message:\", error);\n        }\n      } else {\n        console.log(\"Unhandled message type:\", evt);\n      }\n    });\n    return new Promise((resolve, reject) => {\n      const onError = ev => {\n        this.disconnect(ws);\n        const message = `Could not connect to \"${this.url}\"`;\n        this.log(`server.${ev.type}`, message);\n        reject(new Error(message));\n      };\n      ws.addEventListener(\"error\", onError);\n      ws.addEventListener(\"open\", ev => {\n        this.log(`client.${ev.type}`, `connected to socket`);\n        this.emit(\"open\");\n        this.ws = ws;\n        // Send initial setup message with runId\n        const setupMessage = {\n          setup: {\n            run_id: this.runId,\n            user_id: this.userId\n          }\n        };\n        this._sendDirect(setupMessage);\n        ws.removeEventListener(\"error\", onError);\n        ws.addEventListener(\"close\", ev => {\n          console.log(ev);\n          this.disconnect(ws);\n          let reason = ev.reason || \"\";\n          if (reason.toLowerCase().includes(\"error\")) {\n            const prelude = \"ERROR]\";\n            const preludeIndex = reason.indexOf(prelude);\n            if (preludeIndex > 0) {\n              reason = reason.slice(preludeIndex + prelude.length + 1, Infinity);\n            }\n          }\n          this.log(`server.${ev.type}`, `disconnected ${reason ? `with reason: ${reason}` : ``}`);\n          this.emit(\"close\", ev);\n        });\n        resolve(true);\n      });\n    });\n  }\n  disconnect(ws) {\n    // could be that this is an old websocket and there's already a new instance\n    // only close it if its still the correct reference\n    if ((!ws || this.ws === ws) && this.ws) {\n      this.ws.close();\n      this.ws = null;\n      this.log(\"client.close\", `Disconnected`);\n      return true;\n    }\n    return false;\n  }\n  async receive(blob) {\n    const response = await blobToJSON(blob);\n    console.log(\"Parsed response:\", response);\n    if (isToolCallMessage(response)) {\n      this.log(\"server.toolCall\", response);\n      this.emit(\"toolcall\", response.toolCall);\n      return;\n    }\n    if (isToolCallCancellationMessage(response)) {\n      this.log(\"receive.toolCallCancellation\", response);\n      this.emit(\"toolcallcancellation\", response.toolCallCancellation);\n      return;\n    }\n    if (isSetupCompleteMessage(response)) {\n      this.log(\"server.send\", \"setupComplete\");\n      this.emit(\"setupcomplete\");\n      return;\n    }\n\n    // this json also might be `contentUpdate { interrupted: true }`\n    // or contentUpdate { end_of_turn: true }\n    if (isServerContenteMessage(response)) {\n      const {\n        serverContent\n      } = response;\n      if (isInterrupted(serverContent)) {\n        this.log(\"receive.serverContent\", \"interrupted\");\n        this.emit(\"interrupted\");\n        return;\n      }\n      if (isTurnComplete(serverContent)) {\n        this.log(\"server.send\", \"turnComplete\");\n        this.emit(\"turncomplete\");\n        //plausible there's more to the message, continue\n      }\n      if (isModelTurn(serverContent)) {\n        let parts = serverContent.modelTurn.parts;\n\n        // when its audio that is returned for modelTurn\n        const audioParts = parts.filter(p => p.inlineData && p.inlineData.mimeType.startsWith(\"audio/pcm\"));\n        const base64s = audioParts.map(p => {\n          var _p$inlineData;\n          return (_p$inlineData = p.inlineData) === null || _p$inlineData === void 0 ? void 0 : _p$inlineData.data;\n        });\n\n        // strip the audio parts out of the modelTurn\n        const otherParts = difference(parts, audioParts);\n        // console.log(\"otherParts\", otherParts);\n\n        base64s.forEach(b64 => {\n          if (b64) {\n            const data = base64ToArrayBuffer(b64);\n            this.emit(\"audio\", data);\n            this.log(`server.audio`, `buffer (${data.byteLength})`);\n          }\n        });\n        if (!otherParts.length) {\n          return;\n        }\n        parts = otherParts;\n        const content = {\n          modelTurn: {\n            parts\n          }\n        };\n        this.emit(\"content\", content);\n        this.log(`server.content`, response);\n      }\n    } else {\n      console.log(\"received unmatched message\", response);\n      this.log(\"received unmatched message\", response);\n    }\n  }\n\n  /**\n   * send realtimeInput, this is base64 chunks of \"audio/pcm\" and/or \"image/jpg\"\n   */\n  sendRealtimeInput(chunks) {\n    let hasAudio = false;\n    let hasVideo = false;\n    for (let i = 0; i < chunks.length; i++) {\n      const ch = chunks[i];\n      if (ch.mimeType.includes(\"audio\")) {\n        hasAudio = true;\n      }\n      if (ch.mimeType.includes(\"image\")) {\n        hasVideo = true;\n      }\n      if (hasAudio && hasVideo) {\n        break;\n      }\n    }\n    const message = hasAudio && hasVideo ? \"audio + video\" : hasAudio ? \"audio\" : hasVideo ? \"video\" : \"unknown\";\n    const data = {\n      realtimeInput: {\n        mediaChunks: chunks\n      }\n    };\n    this._sendDirect(data);\n    this.log(`client.realtimeInput`, message);\n  }\n\n  /**\n   *  send a response to a function call and provide the id of the functions you are responding to\n   */\n  sendToolResponse(toolResponse) {\n    const message = {\n      toolResponse\n    };\n    this._sendDirect(message);\n    this.log(`client.toolResponse`, message);\n  }\n\n  /**\n   * send normal content parts such as { text }\n   */\n  send(parts, turnComplete = true) {\n    parts = Array.isArray(parts) ? parts : [parts];\n    const content = {\n      role: \"user\",\n      parts\n    };\n    const clientContentRequest = {\n      clientContent: {\n        turns: [content],\n        turnComplete\n      }\n    };\n    this._sendDirect(clientContentRequest);\n    this.log(`client.send`, clientContentRequest);\n  }\n\n  /**\n   *  used internally to send all messages\n   *  don't use directly unless trying to send an unsupported message type\n   */\n  _sendDirect(request) {\n    if (!this.ws) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n    const str = JSON.stringify(request);\n    this.ws.send(str);\n  }\n}","map":{"version":3,"names":["EventEmitter","difference","isInterrupted","isModelTurn","isServerContenteMessage","isSetupCompleteMessage","isToolCallCancellationMessage","isToolCallMessage","isTurnComplete","blobToJSON","base64ToArrayBuffer","MultimodalLiveClient","constructor","url","userId","runId","ws","config","URL","href","crypto","randomUUID","send","bind","log","type","message","date","Date","emit","connect","newRunId","WebSocket","addEventListener","evt","data","Blob","receive","jsonData","JSON","parse","status","console","error","Promise","resolve","reject","onError","ev","disconnect","Error","setupMessage","setup","run_id","user_id","_sendDirect","removeEventListener","reason","toLowerCase","includes","prelude","preludeIndex","indexOf","slice","length","Infinity","close","blob","response","toolCall","toolCallCancellation","serverContent","parts","modelTurn","audioParts","filter","p","inlineData","mimeType","startsWith","base64s","map","_p$inlineData","otherParts","forEach","b64","byteLength","content","sendRealtimeInput","chunks","hasAudio","hasVideo","i","ch","realtimeInput","mediaChunks","sendToolResponse","toolResponse","turnComplete","Array","isArray","role","clientContentRequest","clientContent","turns","request","str","stringify"],"sources":["C:/SkinLensR/SkinLensR/my-agent-api/frontend/src/utils/multimodal-live-client.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Content, GenerativeContentBlob, Part } from \"@google/generative-ai\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { difference } from \"lodash\";\nimport {\n  ClientContentMessage,\n  isInterrupted,\n  isModelTurn,\n  isServerContenteMessage,\n  isSetupCompleteMessage,\n  isToolCallCancellationMessage,\n  isToolCallMessage,\n  isTurnComplete,\n  LiveIncomingMessage,\n  ModelTurn,\n  RealtimeInputMessage,\n  ServerContent,\n  StreamingLog,\n  ToolCall,\n  ToolCallCancellation,\n  ToolResponseMessage,\n  type LiveConfig,\n} from \"../multimodal-live-types\";\nimport { blobToJSON, base64ToArrayBuffer } from \"./utils\";\n\n/**\n * the events that this client will emit\n */\ninterface MultimodalLiveClientEventTypes {\n  open: () => void;\n  log: (log: StreamingLog) => void;\n  close: (event: CloseEvent) => void;\n  audio: (data: ArrayBuffer) => void;\n  content: (data: ServerContent) => void;\n  interrupted: () => void;\n  setupcomplete: () => void;\n  status: (status: string) => void;\n  turncomplete: () => void;\n  toolcall: (toolCall: ToolCall) => void;\n  toolcallcancellation: (toolcallCancellation: ToolCallCancellation) => void;\n}\n\nexport type MultimodalLiveAPIClientConnection = {\n  url?: string;\n  runId?: string;\n  userId?: string;\n};\n\n/**\n * A event-emitting class that manages the connection to the websocket and emits\n * events to the rest of the application.\n * If you dont want to use react you can still use this.\n */\nexport class MultimodalLiveClient extends EventEmitter<MultimodalLiveClientEventTypes> {\n  public ws: WebSocket | null = null;\n  protected config: LiveConfig | null = null;\n  public url: string = \"\";\n  private runId: string;\n  private userId?: string;\n  constructor({ url, userId, runId }: MultimodalLiveAPIClientConnection) {\n    super();\n    url = url || `ws://localhost:8000/ws`;\n    this.url = new URL(\"ws\", url).href;\n    this.userId = userId;\n    this.runId = runId || crypto.randomUUID(); // Ensure runId is always a string by providing default\n    this.send = this.send.bind(this);\n  }\n\n  log(type: string, message: StreamingLog[\"message\"]) {\n    const log: StreamingLog = {\n      date: new Date(),\n      type,\n      message,\n    };\n    this.emit(\"log\", log);\n  }\n\n  connect(newRunId?: string): Promise<boolean> {\n    const ws = new WebSocket(this.url);\n\n    // Update runId if provided\n    if (newRunId) {\n      this.runId = newRunId;\n    }\n\n    ws.addEventListener(\"message\", async (evt: MessageEvent) => {\n      if (evt.data instanceof Blob) {\n        this.receive(evt.data);\n      } else if (typeof evt.data === \"string\") {\n        try {\n          const jsonData = JSON.parse(evt.data);\n          if (jsonData.status) {\n            this.log(\"server.status\", jsonData.status);\n            console.log(\"Status:\", jsonData.status); // This will show in console\n          }\n        } catch (error) {\n          console.error(\"Error parsing message:\", error);\n        }\n      } else {\n        console.log(\"Unhandled message type:\", evt);\n      }\n    });\n\n    return new Promise((resolve, reject) => {\n      const onError = (ev: Event) => {\n        this.disconnect(ws);\n        const message = `Could not connect to \"${this.url}\"`;\n        this.log(`server.${ev.type}`, message);\n        reject(new Error(message));\n      };\n      ws.addEventListener(\"error\", onError);\n      ws.addEventListener(\"open\", (ev: Event) => {\n        this.log(`client.${ev.type}`, `connected to socket`);\n        this.emit(\"open\");\n\n        this.ws = ws;\n        // Send initial setup message with runId\n        const setupMessage = {\n          setup: {\n            run_id: this.runId,\n            user_id: this.userId,\n          },\n        };\n        this._sendDirect(setupMessage);\n        ws.removeEventListener(\"error\", onError);\n        ws.addEventListener(\"close\", (ev: CloseEvent) => {\n          console.log(ev);\n          this.disconnect(ws);\n          let reason = ev.reason || \"\";\n          if (reason.toLowerCase().includes(\"error\")) {\n            const prelude = \"ERROR]\";\n            const preludeIndex = reason.indexOf(prelude);\n            if (preludeIndex > 0) {\n              reason = reason.slice(\n                preludeIndex + prelude.length + 1,\n                Infinity,\n              );\n            }\n          }\n          this.log(\n            `server.${ev.type}`,\n            `disconnected ${reason ? `with reason: ${reason}` : ``}`,\n          );\n          this.emit(\"close\", ev);\n        });\n        resolve(true);\n      });\n    });\n  }\n\n  disconnect(ws?: WebSocket) {\n    // could be that this is an old websocket and there's already a new instance\n    // only close it if its still the correct reference\n    if ((!ws || this.ws === ws) && this.ws) {\n      this.ws.close();\n      this.ws = null;\n      this.log(\"client.close\", `Disconnected`);\n      return true;\n    }\n    return false;\n  }\n  protected async receive(blob: Blob) {\n    const response = (await blobToJSON(blob)) as LiveIncomingMessage;\n    console.log(\"Parsed response:\", response);\n\n    if (isToolCallMessage(response)) {\n      this.log(\"server.toolCall\", response);\n      this.emit(\"toolcall\", response.toolCall);\n      return;\n    }\n    if (isToolCallCancellationMessage(response)) {\n      this.log(\"receive.toolCallCancellation\", response);\n      this.emit(\"toolcallcancellation\", response.toolCallCancellation);\n      return;\n    }\n\n    if (isSetupCompleteMessage(response)) {\n      this.log(\"server.send\", \"setupComplete\");\n      this.emit(\"setupcomplete\");\n      return;\n    }\n\n    // this json also might be `contentUpdate { interrupted: true }`\n    // or contentUpdate { end_of_turn: true }\n    if (isServerContenteMessage(response)) {\n      const { serverContent } = response;\n      if (isInterrupted(serverContent)) {\n        this.log(\"receive.serverContent\", \"interrupted\");\n        this.emit(\"interrupted\");\n        return;\n      }\n      if (isTurnComplete(serverContent)) {\n        this.log(\"server.send\", \"turnComplete\");\n        this.emit(\"turncomplete\");\n        //plausible there's more to the message, continue\n      }\n\n      if (isModelTurn(serverContent)) {\n        let parts: Part[] = serverContent.modelTurn.parts;\n\n        // when its audio that is returned for modelTurn\n        const audioParts = parts.filter(\n          (p) => p.inlineData && p.inlineData.mimeType.startsWith(\"audio/pcm\"),\n        );\n        const base64s = audioParts.map((p) => p.inlineData?.data);\n\n        // strip the audio parts out of the modelTurn\n        const otherParts = difference(parts, audioParts);\n        // console.log(\"otherParts\", otherParts);\n\n        base64s.forEach((b64) => {\n          if (b64) {\n            const data = base64ToArrayBuffer(b64);\n            this.emit(\"audio\", data);\n            this.log(`server.audio`, `buffer (${data.byteLength})`);\n          }\n        });\n        if (!otherParts.length) {\n          return;\n        }\n\n        parts = otherParts;\n\n        const content: ModelTurn = { modelTurn: { parts } };\n        this.emit(\"content\", content);\n        this.log(`server.content`, response);\n      }\n    } else {\n      console.log(\"received unmatched message\", response);\n      this.log(\"received unmatched message\", response);\n    }\n  }\n\n  /**\n   * send realtimeInput, this is base64 chunks of \"audio/pcm\" and/or \"image/jpg\"\n   */\n  sendRealtimeInput(chunks: GenerativeContentBlob[]) {\n    let hasAudio = false;\n    let hasVideo = false;\n    for (let i = 0; i < chunks.length; i++) {\n      const ch = chunks[i];\n      if (ch.mimeType.includes(\"audio\")) {\n        hasAudio = true;\n      }\n      if (ch.mimeType.includes(\"image\")) {\n        hasVideo = true;\n      }\n      if (hasAudio && hasVideo) {\n        break;\n      }\n    }\n    const message =\n      hasAudio && hasVideo\n        ? \"audio + video\"\n        : hasAudio\n          ? \"audio\"\n          : hasVideo\n            ? \"video\"\n            : \"unknown\";\n\n    const data: RealtimeInputMessage = {\n      realtimeInput: {\n        mediaChunks: chunks,\n      },\n    };\n    this._sendDirect(data);\n    this.log(`client.realtimeInput`, message);\n  }\n\n  /**\n   *  send a response to a function call and provide the id of the functions you are responding to\n   */\n  sendToolResponse(toolResponse: ToolResponseMessage[\"toolResponse\"]) {\n    const message: ToolResponseMessage = {\n      toolResponse,\n    };\n\n    this._sendDirect(message);\n    this.log(`client.toolResponse`, message);\n  }\n\n  /**\n   * send normal content parts such as { text }\n   */\n  send(parts: Part | Part[], turnComplete: boolean = true) {\n    parts = Array.isArray(parts) ? parts : [parts];\n    const content: Content = {\n      role: \"user\",\n      parts,\n    };\n\n    const clientContentRequest: ClientContentMessage = {\n      clientContent: {\n        turns: [content],\n        turnComplete,\n      },\n    };\n\n    this._sendDirect(clientContentRequest);\n    this.log(`client.send`, clientContentRequest);\n  }\n\n  /**\n   *  used internally to send all messages\n   *  don't use directly unless trying to send an unsupported message type\n   */\n  _sendDirect(request: object) {\n    if (!this.ws) {\n      throw new Error(\"WebSocket is not connected\");\n    }\n    const str = JSON.stringify(request);\n    this.ws.send(str);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}