{"ast":null,"code":"/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst AudioRecordingWorklet = `\nclass AudioProcessingWorklet extends AudioWorkletProcessor {\n\n  // send and clear buffer every 2048 samples, \n  // which at 16khz is about 8 times a second\n  buffer = new Int16Array(2048);\n\n  // current write index\n  bufferWriteIndex = 0;\n\n  constructor() {\n    super();\n    this.hasAudio = false;\n  }\n\n  /**\n   * @param inputs Float32Array[][] [input#][channel#][sample#] so to access first inputs 1st channel inputs[0][0]\n   * @param outputs Float32Array[][]\n   */\n  process(inputs) {\n    if (inputs[0].length) {\n      const channel0 = inputs[0][0];\n      this.processChunk(channel0);\n    }\n    return true;\n  }\n\n  sendAndClearBuffer(){\n    this.port.postMessage({\n      event: \"chunk\",\n      data: {\n        int16arrayBuffer: this.buffer.slice(0, this.bufferWriteIndex).buffer,\n      },\n    });\n    this.bufferWriteIndex = 0;\n  }\n\n  processChunk(float32Array) {\n    const l = float32Array.length;\n    \n    for (let i = 0; i < l; i++) {\n      // convert float32 -1 to 1 to int16 -32768 to 32767\n      const int16Value = float32Array[i] * 32768;\n      this.buffer[this.bufferWriteIndex++] = int16Value;\n      if(this.bufferWriteIndex >= this.buffer.length) {\n        this.sendAndClearBuffer();\n      }\n    }\n\n    if(this.bufferWriteIndex >= this.buffer.length) {\n      this.sendAndClearBuffer();\n    }\n  }\n}\n`;\nexport default AudioRecordingWorklet;","map":{"version":3,"names":["AudioRecordingWorklet"],"sources":["C:/SkinLensR/SkinLensR/my-agent-api/frontend/src/utils/worklets/audio-processing.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst AudioRecordingWorklet = `\nclass AudioProcessingWorklet extends AudioWorkletProcessor {\n\n  // send and clear buffer every 2048 samples, \n  // which at 16khz is about 8 times a second\n  buffer = new Int16Array(2048);\n\n  // current write index\n  bufferWriteIndex = 0;\n\n  constructor() {\n    super();\n    this.hasAudio = false;\n  }\n\n  /**\n   * @param inputs Float32Array[][] [input#][channel#][sample#] so to access first inputs 1st channel inputs[0][0]\n   * @param outputs Float32Array[][]\n   */\n  process(inputs) {\n    if (inputs[0].length) {\n      const channel0 = inputs[0][0];\n      this.processChunk(channel0);\n    }\n    return true;\n  }\n\n  sendAndClearBuffer(){\n    this.port.postMessage({\n      event: \"chunk\",\n      data: {\n        int16arrayBuffer: this.buffer.slice(0, this.bufferWriteIndex).buffer,\n      },\n    });\n    this.bufferWriteIndex = 0;\n  }\n\n  processChunk(float32Array) {\n    const l = float32Array.length;\n    \n    for (let i = 0; i < l; i++) {\n      // convert float32 -1 to 1 to int16 -32768 to 32767\n      const int16Value = float32Array[i] * 32768;\n      this.buffer[this.bufferWriteIndex++] = int16Value;\n      if(this.bufferWriteIndex >= this.buffer.length) {\n        this.sendAndClearBuffer();\n      }\n    }\n\n    if(this.bufferWriteIndex >= this.buffer.length) {\n      this.sendAndClearBuffer();\n    }\n  }\n}\n`;\n\nexport default AudioRecordingWorklet;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,qBAAqB,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,eAAeA,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}