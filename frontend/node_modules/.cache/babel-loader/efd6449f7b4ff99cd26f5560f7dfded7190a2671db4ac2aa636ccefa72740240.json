{"ast":null,"code":"/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createWorketFromSrc, registeredWorklets } from \"./audioworklet-registry\";\nexport class AudioStreamer {\n  constructor(context) {\n    this.context = context;\n    this.audioQueue = [];\n    this.isPlaying = false;\n    this.sampleRate = 24000;\n    this.bufferSize = 7680;\n    this.processingBuffer = new Float32Array(0);\n    this.scheduledTime = 0;\n    this.gainNode = void 0;\n    this.source = void 0;\n    this.isStreamComplete = false;\n    this.checkInterval = null;\n    this.initialBufferTime = 0.1;\n    //0.1 // 100ms initial buffer\n    this.endOfQueueAudioSource = null;\n    this.onComplete = () => {};\n    this.gainNode = this.context.createGain();\n    this.source = this.context.createBufferSource();\n    this.gainNode.connect(this.context.destination);\n    this.addPCM16 = this.addPCM16.bind(this);\n  }\n  async addWorklet(workletName, workletSrc, handler) {\n    let workletsRecord = registeredWorklets.get(this.context);\n    if (workletsRecord && workletsRecord[workletName]) {\n      // the worklet already exists on this context\n      // add the new handler to it\n      workletsRecord[workletName].handlers.push(handler);\n      return Promise.resolve(this);\n      //throw new Error(`Worklet ${workletName} already exists on context`);\n    }\n    if (!workletsRecord) {\n      registeredWorklets.set(this.context, {});\n      workletsRecord = registeredWorklets.get(this.context);\n    }\n\n    // create new record to fill in as becomes available\n    workletsRecord[workletName] = {\n      handlers: [handler]\n    };\n    const src = createWorketFromSrc(workletName, workletSrc);\n    await this.context.audioWorklet.addModule(src);\n    const worklet = new AudioWorkletNode(this.context, workletName);\n\n    //add the node into the map\n    workletsRecord[workletName].node = worklet;\n    return this;\n  }\n  addPCM16(chunk) {\n    const float32Array = new Float32Array(chunk.length / 2);\n    const dataView = new DataView(chunk.buffer);\n    for (let i = 0; i < chunk.length / 2; i++) {\n      try {\n        const int16 = dataView.getInt16(i * 2, true);\n        float32Array[i] = int16 / 32768;\n      } catch (e) {\n        console.error(e);\n        // console.log(\n        //   `dataView.length: ${dataView.byteLength},  i * 2: ${i * 2}`,\n        // );\n      }\n    }\n    const newBuffer = new Float32Array(this.processingBuffer.length + float32Array.length);\n    newBuffer.set(this.processingBuffer);\n    newBuffer.set(float32Array, this.processingBuffer.length);\n    this.processingBuffer = newBuffer;\n    while (this.processingBuffer.length >= this.bufferSize) {\n      const buffer = this.processingBuffer.slice(0, this.bufferSize);\n      this.audioQueue.push(buffer);\n      this.processingBuffer = this.processingBuffer.slice(this.bufferSize);\n    }\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      // Initialize scheduledTime only when we start playing\n      this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n      this.scheduleNextBuffer();\n    }\n  }\n  createAudioBuffer(audioData) {\n    const audioBuffer = this.context.createBuffer(1, audioData.length, this.sampleRate);\n    audioBuffer.getChannelData(0).set(audioData);\n    return audioBuffer;\n  }\n  scheduleNextBuffer() {\n    const SCHEDULE_AHEAD_TIME = 0.2;\n    while (this.audioQueue.length > 0 && this.scheduledTime < this.context.currentTime + SCHEDULE_AHEAD_TIME) {\n      const audioData = this.audioQueue.shift();\n      const audioBuffer = this.createAudioBuffer(audioData);\n      const source = this.context.createBufferSource();\n      if (this.audioQueue.length === 0) {\n        if (this.endOfQueueAudioSource) {\n          this.endOfQueueAudioSource.onended = null;\n        }\n        this.endOfQueueAudioSource = source;\n        source.onended = () => {\n          if (!this.audioQueue.length && this.endOfQueueAudioSource === source) {\n            this.endOfQueueAudioSource = null;\n            this.onComplete();\n          }\n        };\n      }\n      source.buffer = audioBuffer;\n      source.connect(this.gainNode);\n      const worklets = registeredWorklets.get(this.context);\n      if (worklets) {\n        Object.entries(worklets).forEach(([workletName, graph]) => {\n          const {\n            node,\n            handlers\n          } = graph;\n          if (node) {\n            source.connect(node);\n            node.port.onmessage = function (ev) {\n              handlers.forEach(handler => {\n                handler.call(node.port, ev);\n              });\n            };\n            node.connect(this.context.destination);\n          }\n        });\n      }\n\n      // i added this trying to fix clicks\n      // this.gainNode.gain.setValueAtTime(0, 0);\n      // this.gainNode.gain.linearRampToValueAtTime(1, 1);\n\n      // Ensure we never schedule in the past\n      const startTime = Math.max(this.scheduledTime, this.context.currentTime);\n      source.start(startTime);\n      this.scheduledTime = startTime + audioBuffer.duration;\n    }\n    if (this.audioQueue.length === 0 && this.processingBuffer.length === 0) {\n      if (this.isStreamComplete) {\n        this.isPlaying = false;\n        if (this.checkInterval) {\n          clearInterval(this.checkInterval);\n          this.checkInterval = null;\n        }\n      } else {\n        if (!this.checkInterval) {\n          this.checkInterval = window.setInterval(() => {\n            if (this.audioQueue.length > 0 || this.processingBuffer.length >= this.bufferSize) {\n              this.scheduleNextBuffer();\n            }\n          }, 100);\n        }\n      }\n    } else {\n      const nextCheckTime = (this.scheduledTime - this.context.currentTime) * 1000;\n      setTimeout(() => this.scheduleNextBuffer(), Math.max(0, nextCheckTime - 50));\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.isStreamComplete = true;\n    this.audioQueue = [];\n    this.processingBuffer = new Float32Array(0);\n    this.scheduledTime = this.context.currentTime;\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    this.gainNode.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);\n    setTimeout(() => {\n      this.gainNode.disconnect();\n      this.gainNode = this.context.createGain();\n      this.gainNode.connect(this.context.destination);\n    }, 200);\n  }\n  async resume() {\n    if (this.context.state === \"suspended\") {\n      await this.context.resume();\n    }\n    this.isStreamComplete = false;\n    this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n    this.gainNode.gain.setValueAtTime(1, this.context.currentTime);\n  }\n  complete() {\n    this.isStreamComplete = true;\n    if (this.processingBuffer.length > 0) {\n      this.audioQueue.push(this.processingBuffer);\n      this.processingBuffer = new Float32Array(0);\n      if (this.isPlaying) {\n        this.scheduleNextBuffer();\n      }\n    } else {\n      this.onComplete();\n    }\n  }\n}\n\n// // Usage example:\n// const audioStreamer = new AudioStreamer();\n//\n// // In your streaming code:\n// function handleChunk(chunk: Uint8Array) {\n//   audioStreamer.handleChunk(chunk);\n// }\n//\n// // To start playing (call this in response to a user interaction)\n// await audioStreamer.resume();\n//\n// // To stop playing\n// // audioStreamer.stop();","map":{"version":3,"names":["createWorketFromSrc","registeredWorklets","AudioStreamer","constructor","context","audioQueue","isPlaying","sampleRate","bufferSize","processingBuffer","Float32Array","scheduledTime","gainNode","source","isStreamComplete","checkInterval","initialBufferTime","endOfQueueAudioSource","onComplete","createGain","createBufferSource","connect","destination","addPCM16","bind","addWorklet","workletName","workletSrc","handler","workletsRecord","get","handlers","push","Promise","resolve","set","src","audioWorklet","addModule","worklet","AudioWorkletNode","node","chunk","float32Array","length","dataView","DataView","buffer","i","int16","getInt16","e","console","error","newBuffer","slice","currentTime","scheduleNextBuffer","createAudioBuffer","audioData","audioBuffer","createBuffer","getChannelData","SCHEDULE_AHEAD_TIME","shift","onended","worklets","Object","entries","forEach","graph","port","onmessage","ev","call","startTime","Math","max","start","duration","clearInterval","window","setInterval","nextCheckTime","setTimeout","stop","gain","linearRampToValueAtTime","disconnect","resume","state","setValueAtTime","complete"],"sources":["C:/SkinLensR/SkinLensR/my-agent-api/frontend/src/utils/audio-streamer.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createWorketFromSrc,\n  registeredWorklets,\n} from \"./audioworklet-registry\";\n\nexport class AudioStreamer {\n  public audioQueue: Float32Array[] = [];\n  private isPlaying: boolean = false;\n  private sampleRate: number = 24000;\n  private bufferSize: number = 7680;\n  private processingBuffer: Float32Array = new Float32Array(0);\n  private scheduledTime: number = 0;\n  public gainNode: GainNode;\n  public source: AudioBufferSourceNode;\n  private isStreamComplete: boolean = false;\n  private checkInterval: number | null = null;\n  private initialBufferTime: number = 0.1; //0.1 // 100ms initial buffer\n  private endOfQueueAudioSource: AudioBufferSourceNode | null = null;\n\n  public onComplete = () => {};\n\n  constructor(public context: AudioContext) {\n    this.gainNode = this.context.createGain();\n    this.source = this.context.createBufferSource();\n    this.gainNode.connect(this.context.destination);\n    this.addPCM16 = this.addPCM16.bind(this);\n  }\n\n  async addWorklet<T extends (d: any) => void>(\n    workletName: string,\n    workletSrc: string,\n    handler: T,\n  ): Promise<this> {\n    let workletsRecord = registeredWorklets.get(this.context);\n    if (workletsRecord && workletsRecord[workletName]) {\n      // the worklet already exists on this context\n      // add the new handler to it\n      workletsRecord[workletName].handlers.push(handler);\n      return Promise.resolve(this);\n      //throw new Error(`Worklet ${workletName} already exists on context`);\n    }\n\n    if (!workletsRecord) {\n      registeredWorklets.set(this.context, {});\n      workletsRecord = registeredWorklets.get(this.context)!;\n    }\n\n    // create new record to fill in as becomes available\n    workletsRecord[workletName] = { handlers: [handler] };\n\n    const src = createWorketFromSrc(workletName, workletSrc);\n    await this.context.audioWorklet.addModule(src);\n    const worklet = new AudioWorkletNode(this.context, workletName);\n\n    //add the node into the map\n    workletsRecord[workletName].node = worklet;\n\n    return this;\n  }\n\n  addPCM16(chunk: Uint8Array) {\n    const float32Array = new Float32Array(chunk.length / 2);\n    const dataView = new DataView(chunk.buffer);\n\n    for (let i = 0; i < chunk.length / 2; i++) {\n      try {\n        const int16 = dataView.getInt16(i * 2, true);\n        float32Array[i] = int16 / 32768;\n      } catch (e) {\n        console.error(e);\n        // console.log(\n        //   `dataView.length: ${dataView.byteLength},  i * 2: ${i * 2}`,\n        // );\n      }\n    }\n\n    const newBuffer = new Float32Array(\n      this.processingBuffer.length + float32Array.length,\n    );\n    newBuffer.set(this.processingBuffer);\n    newBuffer.set(float32Array, this.processingBuffer.length);\n    this.processingBuffer = newBuffer;\n\n    while (this.processingBuffer.length >= this.bufferSize) {\n      const buffer = this.processingBuffer.slice(0, this.bufferSize);\n      this.audioQueue.push(buffer);\n      this.processingBuffer = this.processingBuffer.slice(this.bufferSize);\n    }\n\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      // Initialize scheduledTime only when we start playing\n      this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n      this.scheduleNextBuffer();\n    }\n  }\n\n  private createAudioBuffer(audioData: Float32Array): AudioBuffer {\n    const audioBuffer = this.context.createBuffer(\n      1,\n      audioData.length,\n      this.sampleRate,\n    );\n    audioBuffer.getChannelData(0).set(audioData);\n    return audioBuffer;\n  }\n\n  private scheduleNextBuffer() {\n    const SCHEDULE_AHEAD_TIME = 0.2;\n\n    while (\n      this.audioQueue.length > 0 &&\n      this.scheduledTime < this.context.currentTime + SCHEDULE_AHEAD_TIME\n    ) {\n      const audioData = this.audioQueue.shift()!;\n      const audioBuffer = this.createAudioBuffer(audioData);\n      const source = this.context.createBufferSource();\n\n      if (this.audioQueue.length === 0) {\n        if (this.endOfQueueAudioSource) {\n          this.endOfQueueAudioSource.onended = null;\n        }\n        this.endOfQueueAudioSource = source;\n        source.onended = () => {\n          if (\n            !this.audioQueue.length &&\n            this.endOfQueueAudioSource === source\n          ) {\n            this.endOfQueueAudioSource = null;\n            this.onComplete();\n          }\n        };\n      }\n\n      source.buffer = audioBuffer;\n      source.connect(this.gainNode);\n\n      const worklets = registeredWorklets.get(this.context);\n\n      if (worklets) {\n        Object.entries(worklets).forEach(([workletName, graph]) => {\n          const { node, handlers } = graph;\n          if (node) {\n            source.connect(node);\n            node.port.onmessage = function (ev: MessageEvent) {\n              handlers.forEach((handler) => {\n                handler.call(node.port, ev);\n              });\n            };\n            node.connect(this.context.destination);\n          }\n        });\n      }\n\n      // i added this trying to fix clicks\n      // this.gainNode.gain.setValueAtTime(0, 0);\n      // this.gainNode.gain.linearRampToValueAtTime(1, 1);\n\n      // Ensure we never schedule in the past\n      const startTime = Math.max(this.scheduledTime, this.context.currentTime);\n      source.start(startTime);\n\n      this.scheduledTime = startTime + audioBuffer.duration;\n    }\n\n    if (this.audioQueue.length === 0 && this.processingBuffer.length === 0) {\n      if (this.isStreamComplete) {\n        this.isPlaying = false;\n        if (this.checkInterval) {\n          clearInterval(this.checkInterval);\n          this.checkInterval = null;\n        }\n      } else {\n        if (!this.checkInterval) {\n          this.checkInterval = window.setInterval(() => {\n            if (\n              this.audioQueue.length > 0 ||\n              this.processingBuffer.length >= this.bufferSize\n            ) {\n              this.scheduleNextBuffer();\n            }\n          }, 100) as unknown as number;\n        }\n      }\n    } else {\n      const nextCheckTime =\n        (this.scheduledTime - this.context.currentTime) * 1000;\n      setTimeout(\n        () => this.scheduleNextBuffer(),\n        Math.max(0, nextCheckTime - 50),\n      );\n    }\n  }\n\n  stop() {\n    this.isPlaying = false;\n    this.isStreamComplete = true;\n    this.audioQueue = [];\n    this.processingBuffer = new Float32Array(0);\n    this.scheduledTime = this.context.currentTime;\n\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n\n    this.gainNode.gain.linearRampToValueAtTime(\n      0,\n      this.context.currentTime + 0.1,\n    );\n\n    setTimeout(() => {\n      this.gainNode.disconnect();\n      this.gainNode = this.context.createGain();\n      this.gainNode.connect(this.context.destination);\n    }, 200);\n  }\n\n  async resume() {\n    if (this.context.state === \"suspended\") {\n      await this.context.resume();\n    }\n    this.isStreamComplete = false;\n    this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n    this.gainNode.gain.setValueAtTime(1, this.context.currentTime);\n  }\n\n  complete() {\n    this.isStreamComplete = true;\n    if (this.processingBuffer.length > 0) {\n      this.audioQueue.push(this.processingBuffer);\n      this.processingBuffer = new Float32Array(0);\n      if (this.isPlaying) {\n        this.scheduleNextBuffer();\n      }\n    } else {\n      this.onComplete();\n    }\n  }\n}\n\n// // Usage example:\n// const audioStreamer = new AudioStreamer();\n//\n// // In your streaming code:\n// function handleChunk(chunk: Uint8Array) {\n//   audioStreamer.handleChunk(chunk);\n// }\n//\n// // To start playing (call this in response to a user interaction)\n// await audioStreamer.resume();\n//\n// // To stop playing\n// // audioStreamer.stop();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}